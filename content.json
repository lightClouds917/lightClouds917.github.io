{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"IT云清","url":"https://java4all.cn","root":"/"},"pages":[{"title":"IT云清","date":"2020-01-12T03:21:29.000Z","updated":"2020-01-14T03:48:26.396Z","comments":true,"path":"about/index.html","permalink":"https://java4all.cn/about/index.html","excerpt":"","text":"关于我IT云清 技术栈联系我 Github: IT云清 csdn: IT云清 wechat: IT云清 公众号：java4all 友链 FUNKYE"}],"posts":[{"title":"code review问题总结","slug":"2019代码评审总结","date":"2020-01-04T16:00:00.000Z","updated":"2020-01-14T09:08:38.498Z","comments":true,"path":"2020/01/05/2019代码评审总结/","link":"","permalink":"https://java4all.cn/2020/01/05/2019代码评审总结/","excerpt":"","text":"2019年组织团队成员进行过多次code review，常见出现问题总结如下： 1.变量及命名1.魔法值不要使用魔法值，需要使用的常量提前给出定义。 2.命名规范变量名，方法名，常量等，按照各自规范来，这是基本规范。（可参考：阿里JAVA开发手册-编程规约-命名规范）； 3.枚举使用有业务含义的常量，要定义为枚举，不要仅仅定义为常量。 比如，借款审核状态，有审核中，被拒绝，被关闭，审核通过等多种状态，代码里做判断时，用ONE,TWO这种去判断，阅读代码时是没法理解业务含义的，还得去查这个的ONE究竟是什么含义，要定义借款审核状态的枚举类使用。 4.异步方法命名建议异步方法命名添加个async前缀，让上游调用方知道这个方法是个异步方法，以防使用出错。 5.git提交信息禁止无意义的commit信息，如1，2，update等，没有任何业务含义。 新增功能，修改功能，移除代码，格式化代码，重构，bugfix等，不同类型的操作，要加统一的前缀以区分，否则多分支并行开发时，合并个别提交时，难以摘取；且在code review时，难以区分本次提交的作用和目的，出问题时，回滚提交也难以区分； 每次提交，应该尽量有业务边界的概念，不要在一次pr中，做多件事情； 2.远程调用1.必须做状态校验跨服务远程调用时，对于应答结果，上下游必须做好状态码的商定，下游调用时，必须去校验结果的状态，然后再解析处理。 2.NPE判断不管上游是否做过特殊处理，下游调用时，必须自己做好NPE判断。 3.做好异常处理跨服务调用，异常高发，要做好异常的处理，是重试，还是根据异常类型做对应处理，需要下游自行做好处理。 4.入参出参记录调用前后的入参和出参埋点，出现问题可以及时还原案发现场；如果日志量较大，可以按特定比例（可调整）打印，比如只打印1/20日志。 5.尽量少在大循环里做跨服务调用如果需要在循环中多次调用，建议尝试将单条拉取改为批量拉取，减少调用次数，提高响应速度。 3.异常处理1.合理使用try catch区分稳定代码和不稳定代码，对于稳定代码，不需要try , 不要把整个方法的逻辑都放在try里，出现问题时，难以定位。 2.合理使用日志级别不要全局都使用info级别，出现异常和警告等，使用对应的日志级别，否则出现问题时，本该在error日志中的信息跑到了info中，影响问题排查效率。 3.catch处理catch中，不要简单的留下个自定义字符串，比如“借款审核失败”；异常发生时，一定要记录异常堆栈，还要记录案发现场的入参出参等必要信息，方便还原案发现场。 要避免，线上出现问题，日志只有一句话，为了排查问题，还得加日志加堆栈，然后发个版。 4.非主流程操作出现问题不影响主流程的操作，可以放在try catch里，比如向kafka发送打点日志，避免非主流程操作失败，导致主要业务失败。 5.告警机制部分核心操作，出现问题时，要添加相应的告警机制，比如短信，邮件，钉钉等，开发及时介入解决。 4.BigDecimal使用1.常量定义合理使用构造函数，避免构造出精度缺失的常量。 2.精度问题除法计算时，要使用合理的函数，设置精度，避免无限小数这种结果导致异常。 5.基本规范1.注释作者信息，方法注释等，按照规范来，禁止个性化省略，按照开发规范，风格统一。 2.方法大小适当做好拆分，做好复用，禁止一个方法几百行。","categories":[{"name":"管理","slug":"管理","permalink":"https://java4all.cn/categories/管理/"}],"tags":[{"name":"code review","slug":"code-review","permalink":"https://java4all.cn/tags/code-review/"},{"name":"Java","slug":"Java","permalink":"https://java4all.cn/tags/Java/"},{"name":"管理","slug":"管理","permalink":"https://java4all.cn/tags/管理/"}]},{"title":"Seata 1.0版本整合SpringCloud教程","slug":"Seata1.0版本整合教程","date":"2020-01-04T16:00:00.000Z","updated":"2020-01-14T09:11:29.087Z","comments":true,"path":"2020/01/05/Seata1.0版本整合教程/","link":"","permalink":"https://java4all.cn/2020/01/05/Seata1.0版本整合教程/","excerpt":"","text":"seata 1.0入门教程技术选型及版本spring-cloud-starter-alibaba-seata spring-cloud-alibaba：1.5.1.RELEASE springcloud：Edgware.SR4 seata-all：1.0.0 springboot：1.5.4 mybatis-spring-boot-starter.version：2.0.0 java：jdk8 1.启动seata server下载包：https://github.com/seata/seata/releases 解压：tar -xzvf seata-server-1.0.0.tar.gz 修改配置： 1.配置registry.conf123456789101112131415161718192021222324252627[root@jr-test conf]# cat registry.conf //注册中心registry &#123; # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa type = \"eureka\" //注册中心类型 nacos &#123; serverAddr = \"localhost\" namespace = \"\" cluster = \"default\" &#125; eureka &#123; serviceUrl = \"http://192.xx.xx.xx:8761/eureka\" //注册中心地址 application = \"fsp_tx\" //tc注册时的名称 weight = \"1\" &#125; //......支持多种&#125;//配置中心config &#123; # file、nacos 、apollo、zk、consul、etcd3 type = \"file\" //配置中心类型 file &#123; name = \"file.conf\" // &#125; //......支持多种&#125; 2.配置file.conf123456789101112131415161718192021222324252627282930313233[root@jr-test conf]# cat file.confservice &#123; #transaction service group mapping vgroup_mapping.default = \"fsp_tx\" //事务分组，非常重要，client和tc一定要一致，default是个自定义的分组名称 #only support when registry.type=file, please don't set multiple addresses default.grouplist = \"127.0.0.1:8091\" #disable seata disableGlobalTransaction = false&#125;## transaction log store, only used in seata-serverstore &#123; ## store mode: file、db mode = \"db\" //事务日志存储模式 ## file store property file &#123; ## store location dir dir = \"sessionStore\" &#125; ## database store property db &#123; ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc. datasource = \"dbcp\" ## mysql/oracle/h2/oceanbase etc. db-type = \"mysql\" driver-class-name = \"com.mysql.jdbc.Driver\" url = \"jdbc:mysql://192.xx.xx.xx:3306/seata\" // tc的数据库,可自定义命名，对应就好 user = \"root\" password = \"xxx\" &#125;&#125; 3.建表全局事务会话信息由3块内容构成： 全局事务 global_table 分支事务 branch_table 全局锁 lock_table 建表语句在：https://github.com/seata/seata/tree/develop/script/server/db 4.启动tcbin目录下： 1nohup sh seata-server.sh -h xx.xx.xx.xx -p 8091 -m db -n 1 &amp; 这里是以nohup的方式后台启动，参数可选： -h: 注册到注册中心的ip -p: Server rpc 监听端口 -m: 全局事务会话信息存储模式，file、db，优先读取启动参数 -n: Server node，多个Server时，需区分各自节点，用于生成不同区间的transactionId，以免冲突 -e: 多环境配置参考 http://seata.io/en-us/docs/ops/multi-configuration-isolation.html 2.client端引入seata依赖目前有三种方式，相应的支持程度不同： 依赖 支持yml配置 实现xid传递 支持数据源自动代理 自动初始化GlobalTransactionScanner入口 seata-all 否 否 是 否 seata-spring-boot-starter 是 否 是 是 spring-cloud-alibaba-seata 否 是 是 是 不建议用户仅引入seata-all，需要自行实现的东西太多。 spring-cloud-alibaba-seata，2.1.0内嵌seata-all 0.7.1，2.1.1内嵌seata-all 0.9.0。建议排除掉，引入1.0； 我们这里以引入spring-cloud-alibaba-seata 依赖为例，下面仅展示与seata相关的依赖： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;properties&gt; &lt;spring-cloud.version&gt;Edgware.SR4&lt;/spring-cloud.version&gt; &lt;spring-cloud-alibaba.version&gt;1.5.1.RELEASE&lt;/spring-cloud-alibaba.version&gt; &lt;seata-version&gt;1.0.0&lt;/seata-version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!--seata-all--&gt; &lt;dependency&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;artifactId&gt;seata-all&lt;/artifactId&gt; &lt;version&gt;$&#123;seata-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--sca-seata--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--Spring Cloud--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--Spring Cloud Alibaba，包含seata-all 0.9,这里排除掉，换为1.0--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;seata-all&lt;/artifactId&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 3.client端引入配置文件seata server端和client端的脚本和配置，都汇总在这里，client端整合时，去找对应的文件复制过来修改。 https://github.com/seata/seata/tree/develop/script 1.修改bootstrap.yml添加事务分组 12345spring: cloud: alibaba: seata: tx-service-group: default //这个default是事务分组名称，与server端的事务分组名称保持一致 这个分组名称自定义，但是seata server端，client端要保持一致。 2.配置file.conf引入配置文件，并修改相关配置，由于有很多配置项，不是每个都需要去改一遍，这里只是改动少数，让你先能整合进去跑起来，其他的参数后面再自己调整。 file.conf 123456789101112131415161718192021//省略很多service &#123; #transaction service group mapping vgroup_mapping.default = \"fsp_tx\" //这个default是事务分组名称，与server端的事务分组名称保持一致 #only support when registry.type=file, please don't set multiple addresses default.grouplist = \"127.0.0.1:8091\" #degrade, current not support enableDegrade = false #disable seata disableGlobalTransaction = false&#125;client &#123; //省略很多 rm &#123; report.success.enable = true //一阶段成功后是否上报tc，这个配置可以提高性能 &#125; support &#123; # auto proxy the DataSource bean //数据源自动代理 spring.datasource.autoproxy = false &#125;&#125; 3.配置registry.conf注册中心和配置中心，都支持多种，按照自己的技术选型，修改对应的配置。 12345678910111213141516171819registry &#123; # file 、nacos 、eureka、redis、zk type = \"eureka\" eureka &#123; serviceUrl = \"http://192.xx.xx.xx:8761/eureka\" application = \"fsp_tx\" weight = \"1\" &#125; //省略&#125;config &#123; # file、nacos 、apollo、zk type = \"file\" file &#123; name = \"file.conf\" &#125; //省略&#125; 4.配置数据源头代理如果支持自动代理，那就开启配置就好，这里示例下使用mysql和mybatis时，如何自行代理数据源。 1234567891011121314151617181920212223242526272829303132333435363738394041424344package io.seata.sample;import com.alibaba.druid.pool.DruidDataSource;import io.seata.rm.datasource.DataSourceProxy;import javax.sql.DataSource;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.transaction.SpringManagedTransactionFactory;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.core.io.support.PathMatchingResourcePatternResolver;/** * 数据源代理 * @author IT云清 */@Configurationpublic class DataSourceConfiguration &#123; @Bean @ConfigurationProperties(prefix = \"spring.datasource\") public DataSource druidDataSource()&#123; DruidDataSource druidDataSource = new DruidDataSource(); return druidDataSource; &#125; @Primary @Bean(\"dataSource\") public DataSourceProxy dataSource(DataSource druidDataSource)&#123; return new DataSourceProxy(druidDataSource); &#125; @Bean public SqlSessionFactory sqlSessionFactory(DataSourceProxy dataSourceProxy)throws Exception&#123; SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSourceProxy); sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver() .getResources(\"classpath*:/mapper/*.xml\")); sqlSessionFactoryBean.setTransactionFactory(new SpringManagedTransactionFactory()); return sqlSessionFactoryBean.getObject(); &#125;&#125; 5.实现xid传递如果你引入的依赖和技术选型，没有实现xid传递等逻辑，你需要参考源码integration文件夹下的各种rpc实现 module。 https://github.com/seata/seata/tree/develop/integration 6.实现scanner入口如果你引入的依赖和技术选型，没有实现初始化GlobalTransactionScanner逻辑，可以自行实现如下： 1.SeataProperties.java 123456789101112@ConfigurationProperties(\"spring.cloud.alibaba.seata\")public class SeataProperties &#123; private String txServiceGroup; public SeataProperties() &#123; &#125; public String getTxServiceGroup() &#123; return this.txServiceGroup; &#125; public void setTxServiceGroup(String txServiceGroup) &#123; this.txServiceGroup = txServiceGroup; &#125;&#125; 2.初始化GlobalTransactionScanner 123456789101112131415161718192021222324252627282930313233343536373839404142package com.runlion.fsp.credit.seata.config;import com.runlion.fsp.credit.seata.SeataProperties;import io.seata.spring.annotation.GlobalTransactionScanner;import org.apache.commons.lang.StringUtils;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @author IT云清 */@Configuration@EnableConfigurationProperties(&#123;SeataProperties.class&#125;)public class GlobalTransactionAutoConfiguration &#123; private static final String APPLICATION_NAME_PREFIX = \"spring.application.name\"; private static final String DEFAULT_TX_SERVICE_GROUP_SUFFIX = \"-seata-service-group\"; private final ApplicationContext applicationContext; private final SeataProperties seataProperties; public GlobalTransactionAutoConfiguration( ApplicationContext applicationContext, SeataProperties seataProperties) &#123; this.applicationContext = applicationContext; this.seataProperties = seataProperties; &#125; /** * If there is no txServiceGroup,use the default * @return GlobalTransactionScanner the entrance */ @Bean public GlobalTransactionScanner globalTransactionScanner()&#123; String applicationName = this.applicationContext.getEnvironment().getProperty(APPLICATION_NAME_PREFIX); String txServiceGroup = seataProperties.getTxServiceGroup(); if(StringUtils.isEmpty(txServiceGroup))&#123; txServiceGroup = applicationName + DEFAULT_TX_SERVICE_GROUP_SUFFIX; this.seataProperties.setTxServiceGroup(txServiceGroup); &#125; return new GlobalTransactionScanner(applicationName,txServiceGroup); &#125;&#125; 7.建表如果要使用seata分布式事务，当前服务就需要建一张undolog表。 建表语句参考：https://github.com/seata/seata/tree/develop/script/client/at/db 8.使用 1.@GlobalTransaction 全局事务注解 2.@GlobalLock 防止脏读和脏写，又不想纳入全局事务管理时使用。（不需要rpc和xid传递等成本） 9.辅助信息如果发现数据不一致，可以参考下面的一些典型日志，或者查找关键字，比如Successfully begin global transaction，Successfully register branch xid = 。。。可以辅助你确认你的配置是否正确有效，各分支事务是否注册，纳入全局管理。1.client端如果正常启动，在server端会有如下日志，否则，请再检查配置：122019-12-31 15:38:44.170 INFO [ServerHandlerThread_1_500]io.seata.core.rpc.DefaultServerMessageListenerImpl.onRegRmMessage:123 -rm register success,message:RegisterRMRequest&#123;resourceIds='jdbc:mysql://116.xx.xx.xx/seata-account', applicationId='account-server', transactionServiceGroup='default'&#125;,channel:[id: 0xb58488ac, L:/192.xx.xx.xx:8091 - R:/192.xx.xx.xx:13641]2019-12-31 15:38:44.968 INFO [NettyServerNIOWorker_1_8]io.seata.core.rpc.DefaultServerMessageListenerImpl.onRegTmMessage:140 -checkAuth for client:192.xx.xx.xx:13644,vgroup:default,applicationId:account-server 2.全局事务提交成功,server端会有日志如下：1234567891011121314151617181920212223242019-12-31 16:00:31.209 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:205 -SeataMergeMessage timeout=60000,transactionName=fsp-create-order,clientIp:192.xx.xx.xx,vgroup:default2019-12-31 16:00:31.211 INFO [ServerHandlerThread_1_500]io.seata.server.coordinator.DefaultCore.begin:154 -Successfully begin global transaction xid = 192.xx.xx.xx:8091:20310756922019-12-31 16:00:31.253 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:205 -SeataMergeMessage xid=192.xx.xx.xx:8091:2031075692,branchType=AT,resourceId=jdbc:mysql://116.62.62.26/seata-order,lockKey=order:877,clientIp:192.xx.xx.xx,vgroup:default2019-12-31 16:00:31.257 INFO [ServerHandlerThread_1_500]io.seata.server.coordinator.DefaultCore.lambda$branchRegister$0:98 -Successfully register branch xid = 192.xx.xx.xx:8091:2031075692, branchId = 20310756942019-12-31 16:00:31.278 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:205 -SeataMergeMessage xid=192.xx.xx.xx:8091:2031075692,branchId=2031075694,resourceId=null,status=PhaseOne_Done,applicationData=null,clientIp:192.xx.xx.xx,vgroup:default2019-12-31 16:00:31.283 INFO [ServerHandlerThread_1_500]io.seata.server.coordinator.DefaultCore.branchReport:126 -Successfully branch report xid = 192.xx.xx.xx:8091:2031075692, branchId = 20310756942019-12-31 16:00:31.339 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:205 -SeataMergeMessage xid=192.xx.xx.xx:8091:2031075692,branchType=AT,resourceId=jdbc:mysql://116.62.62.26/seata-storage,lockKey=storage:1,clientIp:192.xx.xx.xx,vgroup:default2019-12-31 16:00:31.344 INFO [ServerHandlerThread_1_500]io.seata.server.coordinator.DefaultCore.lambda$branchRegister$0:98 -Successfully register branch xid = 192.xx.xx.xx:8091:2031075692, branchId = 20310756972019-12-31 16:00:31.363 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:205 -SeataMergeMessage xid=192.xx.xx.xx:8091:2031075692,branchId=2031075697,resourceId=null,status=PhaseOne_Done,applicationData=null,clientIp:192.xx.xx.xx,vgroup:default2019-12-31 16:00:31.366 INFO [ServerHandlerThread_1_500]io.seata.server.coordinator.DefaultCore.branchReport:126 -Successfully branch report xid = 192.xx.xx.xx:8091:2031075692, branchId = 20310756972019-12-31 16:00:32.237 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:205 -SeataMergeMessage xid=192.xx.xx.xx:8091:2031075692,branchType=AT,resourceId=jdbc:mysql://116.62.62.26/seata-account,lockKey=account:1,clientIp:192.xx.xx.xx,vgroup:default2019-12-31 16:00:32.242 INFO [ServerHandlerThread_1_500]io.seata.server.coordinator.DefaultCore.lambda$branchRegister$0:98 -Successfully register branch xid = 192.xx.xx.xx:8091:2031075692, branchId = 20310757012019-12-31 16:00:32.294 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:205 -SeataMergeMessage xid=192.xx.xx.xx:8091:2031075692,branchId=2031075701,resourceId=null,status=PhaseOne_Done,applicationData=null,clientIp:192.xx.xx.xx,vgroup:default2019-12-31 16:00:32.327 INFO [ServerHandlerThread_1_500]io.seata.server.coordinator.DefaultCore.branchReport:126 -Successfully branch report xid = 192.xx.xx.xx:8091:2031075692, branchId = 20310757012019-12-31 16:00:32.368 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:205 -SeataMergeMessage xid=192.xx.xx.xx:8091:2031075692,extraData=null,clientIp:192.xx.xx.xx,vgroup:default2019-12-31 16:00:32.775 INFO [AsyncCommitting_1]io.seata.server.coordinator.DefaultCore.doGlobalCommit:316 -Global[192.xx.xx.xx:8091:2031075692] committing is successfully done. 3.全局事务提交失败,server端会有日志如下：12345678910111213141516171819202019-12-31 16:16:50.327 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:205 -SeataMergeMessage timeout=60000,transactionName=fsp-create-order,clientIp:192.xx.xx.xx,vgroup:default2019-12-31 16:16:50.329 INFO [ServerHandlerThread_1_500]io.seata.server.coordinator.DefaultCore.begin:154 -Successfully begin global transaction xid = 192.xx.xx.xx:8091:20310757092019-12-31 16:16:50.408 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:205 -SeataMergeMessage xid=192.xx.xx.xx:8091:2031075709,branchType=AT,resourceId=jdbc:mysql://116.62.62.26/seata-order,lockKey=order:878,clientIp:192.xx.xx.xx,vgroup:default2019-12-31 16:16:50.412 INFO [ServerHandlerThread_1_500]io.seata.server.coordinator.DefaultCore.lambda$branchRegister$0:98 -Successfully register branch xid = 192.xx.xx.xx:8091:2031075709, branchId = 20310757112019-12-31 16:16:50.432 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:205 -SeataMergeMessage xid=192.xx.xx.xx:8091:2031075709,branchId=2031075711,resourceId=null,status=PhaseOne_Done,applicationData=null,clientIp:192.xx.xx.xx,vgroup:default2019-12-31 16:16:50.435 INFO [ServerHandlerThread_1_500]io.seata.server.coordinator.DefaultCore.branchReport:126 -Successfully branch report xid = 192.xx.xx.xx:8091:2031075709, branchId = 20310757112019-12-31 16:16:50.520 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:205 -SeataMergeMessage xid=192.xx.xx.xx:8091:2031075709,branchType=AT,resourceId=jdbc:mysql://116.62.62.26/seata-storage,lockKey=storage:1,clientIp:192.xx.xx.xx,vgroup:default2019-12-31 16:16:50.523 INFO [ServerHandlerThread_1_500]io.seata.server.coordinator.DefaultCore.lambda$branchRegister$0:98 -Successfully register branch xid = 192.xx.xx.xx:8091:2031075709, branchId = 20310757142019-12-31 16:16:50.541 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:205 -SeataMergeMessage xid=192.xx.xx.xx:8091:2031075709,branchId=2031075714,resourceId=null,status=PhaseOne_Done,applicationData=null,clientIp:192.xx.xx.xx,vgroup:default2019-12-31 16:16:50.544 INFO [ServerHandlerThread_1_500]io.seata.server.coordinator.DefaultCore.branchReport:126 -Successfully branch report xid = 192.xx.xx.xx:8091:2031075709, branchId = 20310757142019-12-31 16:16:52.569 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:205 -SeataMergeMessage xid=192.xx.xx.xx:8091:2031075709,extraData=null,clientIp:192.xx.xx.xx,vgroup:default2019-12-31 16:16:52.626 INFO [ServerHandlerThread_1_500]io.seata.server.coordinator.DefaultCore.doGlobalRollback:418 -Successfully rollback branch xid=192.xx.xx.xx:8091:2031075709 branchId=20310757142019-12-31 16:16:52.693 INFO [ServerHandlerThread_1_500]io.seata.server.coordinator.DefaultCore.doGlobalRollback:418 -Successfully rollback branch xid=192.xx.xx.xx:8091:2031075709 branchId=20310757112019-12-31 16:16:52.696 INFO [ServerHandlerThread_1_500]io.seata.server.coordinator.DefaultCore.doGlobalRollback:465 -Successfully rollback global, xid = 192.xx.xx.xx:8091:2031075709","categories":[{"name":"Seata","slug":"Seata","permalink":"https://java4all.cn/categories/Seata/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://java4all.cn/tags/Java/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://java4all.cn/tags/SpringCloud/"},{"name":"Seata","slug":"Seata","permalink":"https://java4all.cn/tags/Seata/"}]},{"title":"SpringCloud教程(Finchley版本)-02：服务消费者","slug":"SpringCloud教程(Finchley版本)-02：服务消费者","date":"2018-01-04T16:00:00.000Z","updated":"2020-01-14T10:52:15.213Z","comments":true,"path":"2018/01/05/SpringCloud教程(Finchley版本)-02：服务消费者/","link":"","permalink":"https://java4all.cn/2018/01/05/SpringCloud教程(Finchley版本)-02：服务消费者/","excerpt":"","text":"本文，讲述如何将一个服务注册到eureka注册中心，主要分为以下几个步骤： 1.新建项目 2.引入eureka依赖 3.添加注解 4.修改配置文件 5.新建一个controller，提供一个服务接口 6.启动项目 由于后续需要演示负载均衡，这里会创建两个项目company_server1，company_server2，这两个项目提供完全相同的服务，注册到注册中心时，使用相同的服务名称company-server，由于是两个服务，所以项目的端口是不同的，其他相同。具体步骤如下：1.新建项目新建一个SpringBoot项目company_server1。 2.引入eureka依赖eureka-client依赖： 12345&lt;!--eureka client--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; springcloud依赖，在 标签外面： 123456789101112&lt;!--springcloud依赖管理--&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 1&lt;spring-cloud.version&gt;Finchley.SR2&lt;/spring-cloud.version&gt; 3.添加注解在启动类添加注解@EnableEurekaClient，将项目启动为一个以eureka做注册中心的服务。 12345678@EnableEurekaClient@SpringBootApplicationpublic class CompanyServer1Application &#123; public static void main(String[] args) &#123; SpringApplication.run(CompanyServer1Application.class, args); &#125;&#125; 4.修改配置文件123456789server: port: 8011spring: application: name: company-servereureka: client: service-url: defaultZone: http://localhost:8761/eureka name: company-server，就是把此项目注册到注册中心时，服务名为company-server，后面其他项目，通过这个服务名称，就能找到这个服务，而不需要通过ip:port。 5.新建一个controller，提供一个服务接口我们新建一个controller包，下面建一个CompanyController，里面写一个服务接口，对外提供服务，代码如下: 123456789101112@RestController@RequestMapping(&quot;company&quot;)public class CompanyController &#123; @Value(&quot;$&#123;server.port&#125;&quot;) String port; @GetMapping(&quot;get&quot;) public String getCompany(Integer id)&#123; return &quot;port:&quot;+port+&quot;,企业信息为：阿里巴巴&quot;+id; &#125;&#125; 6.启动项目启动项目，会发现项目注册到了注册中心上：访问接口http://localhost:8011/company/get?id=2，发现接口也可以提供服务。然后我们再写一个相同的服务，步骤和上面一样，端口改为8014，注册时，服务名和上面一样，也是company-server，提供相同的服务，方便后面演示负载均衡。 下一篇：SpringCloud教程(Finchley版本)-03：负载均衡（Ribbon）完整源码参考：https://github.com/myJava4all/springcloudfinchley","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://java4all.cn/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://java4all.cn/tags/SpringCloud/"}]},{"title":"SpringCloud教程(Finchley版本)-01：服务注册与发现（Eureka）","slug":"SpringCloud教程(Finchley版本)-01：服务注册与发现（Eureka）","date":"2018-01-04T16:00:00.000Z","updated":"2020-01-14T10:55:55.607Z","comments":true,"path":"2018/01/05/SpringCloud教程(Finchley版本)-01：服务注册与发现（Eureka）/","link":"","permalink":"https://java4all.cn/2018/01/05/SpringCloud教程(Finchley版本)-01：服务注册与发现（Eureka）/","excerpt":"","text":"本文，讲述如何启动一个项目作为eureka注册中心，主要分为以下几个步骤： 1.新建项目 2.引入eureka依赖 3.添加注解 4.修改配置文件 5.启动项目 1.新建项目（注册中心）新建一个SpringBoot项目eureka_server，作为注册中心，后续的其他项目，都注册在这个注册中心上面。 2.引入eureka依赖这里和普通springboot项目相比，主要就是需要多引入两个依赖：eureka的，spring-cloud相关的。 eureka-server依赖： 12345&lt;!--eureka-server--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt; springcloud依赖，在 标签外面： 123456789101112&lt;!--spring-cloud依赖--&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 1&lt;spring-cloud.version&gt;Finchley.SR2&lt;/spring-cloud.version&gt; 3.添加注解在项目的启动类中，添加@EnableEurekaServer注解，将此项目启动为注册中心。 123456789//启动为一个注册中心@EnableEurekaServer@SpringBootApplicationpublic class EurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServerApplication.class, args); &#125;&#125; 4.修改配置文件在配置文件中配置注册中心相关信息 12345678910111213server: port: 8761spring: application: name: eureka-servereureka: instance: hostname: localhost client: register-with-eureka: false fetch-registry: false service-url: defultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 解释一下： register-with-eureka: false，是否注册到eureka服务器，由于自己就是eureka服务器，没有必要注册自身。 fetch-registry: false：是否从eureka服务器获取注册信息，这里也没必要。 defultZone：设置eureka服务器所在地址，注册服务和查询服务都依靠这个地址。 5.启动项目启动项目，访问http://localhost:8761/，会看到如下画面，说明注册中心启动成功，后续当有服务注册进来时，都会在这里显示。 下一篇：SpringCloud教程(Finchley版本)-02：服务消费者完整源码参考：https://github.com/myJava4all/springcloudfinchley","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://java4all.cn/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://java4all.cn/tags/SpringCloud/"},{"name":"Eureka","slug":"Eureka","permalink":"https://java4all.cn/tags/Eureka/"}]},{"title":"SpringCloud教程(Finchley版本)-03：负载均衡（Ribbon）","slug":"SpringCloud教程(Finchley版本)-03：负载均衡（Ribbon）","date":"2018-01-04T16:00:00.000Z","updated":"2020-01-14T11:00:38.812Z","comments":true,"path":"2018/01/05/SpringCloud教程(Finchley版本)-03：负载均衡（Ribbon）/","link":"","permalink":"https://java4all.cn/2018/01/05/SpringCloud教程(Finchley版本)-03：负载均衡（Ribbon）/","excerpt":"","text":"Spring Cloud Ribbon是一个基于Http和TCP的客服端负载均衡工具，它是基于Netflix Ribbon实现的。它是一个工具类框架，不像服务注册中心、配置中心、API网关那样独立部署，但是它几乎存在于每个微服务的基础设施中。微服务间的调用，API网关的请求转发等，都是通过Ribbon来实现的，包括后面要介绍的Feign，也是基于Ribbon实现的工具。 本文介绍如何使用Ribbon来实现客户端的负载均衡。主要分为以下几个步骤： 1.创建项目 2.引入依赖 3.修改配置文件 4.添加启动注解 5.注入模板类 6.跨服务调用 7.启动项目，测试 1.创建项目新建一个Springboot项目ribbon_server1。 2.引入依赖ribbon依赖和eureka依赖 1234567891011&lt;!--eureka-client--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--eureka ribbon--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;&lt;/dependency&gt; springcloud依赖，在 标签外面： 123456789101112&lt;!--spring-cloud依赖--&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 1&lt;spring-cloud.version&gt;Finchley.SR2&lt;/spring-cloud.version&gt; 3.修改配置文件123456789server: port: 8016spring: application: name: service-ribboneureka: client: service-url: defaultZone: http://localhost:8761/eureka/ 4.添加启动注解启动类中，照例要给注册为一个eurekaClient，添加@EnableEurekaClient 5.注入模板类在启动类中，注入RestTemplate模板到容器中，该对象会使用Ribbon的自动化配置，当开启了@LoadBalanced后，可以开启客户端负载均衡。 123456789101112131415161718@EnableEurekaClient@SpringBootApplicationpublic class RibbonServer1Application &#123; /** * * @Bean ： 注入一个名为restTemplate的bean * @LoadBalanced ：表明这个 restTemplate 开启了负载均衡的功能 * * */ @Bean @LoadBalanced RestTemplate restTemplate()&#123;return new RestTemplate();&#125; public static void main(String[] args) &#123; SpringApplication.run(RibbonServer1Application.class, args); &#125;&#125; 6.跨服务调用写一套简单的业务代码，然后调用前面创建的company-server服务提供的接口。 6.1 controller1234567891011121314@RestController//@RequestMapping(value = &quot;ribbon&quot;)public class RibbonController &#123; @Autowired private RibbonService ribbonService; @GetMapping(value = &quot;getCompany&quot;) public String getCompany(String id)&#123; String company = ribbonService.getCompany(id); System.out.println(company); return company; &#125;&#125; 6.2 service1234public interface RibbonService &#123; String getCompany(String id);&#125; 6.3 serviceImpl在serviceImpl实现类中，我们引入前面的RestTemplate模板类，来跨服务调用，并开启了负载均衡功能。 123456789101112131415@Servicepublic class RibbonServiceImpl implements RibbonService&#123; //启动类中注入了此模板，并且开启了负载均衡功能 @Autowired RestTemplate restTemplate; //程序名替代服务地址，ribbon会根据服务名自动选择服务实例 @Override public String getCompany(String id) &#123; String company = restTemplate .getForObject(&quot;http://company-server/company/get?id=&quot; + id, String.class); return company; &#125;&#125; 7.启动项目，测试启动项目，访问这个项目的接口http://localhost:8016/getCompany?id=1234，会发现，这个服务调用了company-server服务提供的接口，并且，接口在两个相同的服务间自动切换，也就是，实现了负载均衡的功能。 不断刷新接口，可以看到服务方发生了切换，如下：当然，restTemplate提供了多种方法，get,post,delete,put等方法，这里只是示例了一种。 下一篇：SpringCloud教程(Finchley版本)-04：断路器（Hystrix-Ribbon）完整源码参考：https://github.com/myJava4all/springcloudfinchley","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://java4all.cn/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://java4all.cn/tags/SpringCloud/"},{"name":"Ribbon","slug":"Ribbon","permalink":"https://java4all.cn/tags/Ribbon/"}]}]}