{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"IT云清","url":"https://java4all.cn","root":"/"},"pages":[{"title":"IT云清","date":"2020-01-12T03:21:29.000Z","updated":"2020-01-14T03:48:26.396Z","comments":true,"path":"about/index.html","permalink":"https://java4all.cn/about/index.html","excerpt":"","text":"关于我IT云清 技术栈联系我 Github: IT云清 csdn: IT云清 wechat: IT云清 公众号：java4all 友链 FUNKYE"}],"posts":[{"title":"code review问题总结","slug":"2019代码评审总结","date":"2020-01-04T16:00:00.000Z","updated":"2020-01-14T09:08:38.498Z","comments":true,"path":"2020/01/05/2019代码评审总结/","link":"","permalink":"https://java4all.cn/2020/01/05/2019代码评审总结/","excerpt":"","text":"2019年组织团队成员进行过多次code review，常见出现问题总结如下： 1.变量及命名1.魔法值不要使用魔法值，需要使用的常量提前给出定义。 2.命名规范变量名，方法名，常量等，按照各自规范来，这是基本规范。（可参考：阿里JAVA开发手册-编程规约-命名规范）； 3.枚举使用有业务含义的常量，要定义为枚举，不要仅仅定义为常量。 比如，借款审核状态，有审核中，被拒绝，被关闭，审核通过等多种状态，代码里做判断时，用ONE,TWO这种去判断，阅读代码时是没法理解业务含义的，还得去查这个的ONE究竟是什么含义，要定义借款审核状态的枚举类使用。 4.异步方法命名建议异步方法命名添加个async前缀，让上游调用方知道这个方法是个异步方法，以防使用出错。 5.git提交信息禁止无意义的commit信息，如1，2，update等，没有任何业务含义。 新增功能，修改功能，移除代码，格式化代码，重构，bugfix等，不同类型的操作，要加统一的前缀以区分，否则多分支并行开发时，合并个别提交时，难以摘取；且在code review时，难以区分本次提交的作用和目的，出问题时，回滚提交也难以区分； 每次提交，应该尽量有业务边界的概念，不要在一次pr中，做多件事情； 2.远程调用1.必须做状态校验跨服务远程调用时，对于应答结果，上下游必须做好状态码的商定，下游调用时，必须去校验结果的状态，然后再解析处理。 2.NPE判断不管上游是否做过特殊处理，下游调用时，必须自己做好NPE判断。 3.做好异常处理跨服务调用，异常高发，要做好异常的处理，是重试，还是根据异常类型做对应处理，需要下游自行做好处理。 4.入参出参记录调用前后的入参和出参埋点，出现问题可以及时还原案发现场；如果日志量较大，可以按特定比例（可调整）打印，比如只打印1/20日志。 5.尽量少在大循环里做跨服务调用如果需要在循环中多次调用，建议尝试将单条拉取改为批量拉取，减少调用次数，提高响应速度。 3.异常处理1.合理使用try catch区分稳定代码和不稳定代码，对于稳定代码，不需要try , 不要把整个方法的逻辑都放在try里，出现问题时，难以定位。 2.合理使用日志级别不要全局都使用info级别，出现异常和警告等，使用对应的日志级别，否则出现问题时，本该在error日志中的信息跑到了info中，影响问题排查效率。 3.catch处理catch中，不要简单的留下个自定义字符串，比如“借款审核失败”；异常发生时，一定要记录异常堆栈，还要记录案发现场的入参出参等必要信息，方便还原案发现场。 要避免，线上出现问题，日志只有一句话，为了排查问题，还得加日志加堆栈，然后发个版。 4.非主流程操作出现问题不影响主流程的操作，可以放在try catch里，比如向kafka发送打点日志，避免非主流程操作失败，导致主要业务失败。 5.告警机制部分核心操作，出现问题时，要添加相应的告警机制，比如短信，邮件，钉钉等，开发及时介入解决。 4.BigDecimal使用1.常量定义合理使用构造函数，避免构造出精度缺失的常量。 2.精度问题除法计算时，要使用合理的函数，设置精度，避免无限小数这种结果导致异常。 5.基本规范1.注释作者信息，方法注释等，按照规范来，禁止个性化省略，按照开发规范，风格统一。 2.方法大小适当做好拆分，做好复用，禁止一个方法几百行。","categories":[{"name":"管理","slug":"管理","permalink":"https://java4all.cn/categories/管理/"}],"tags":[{"name":"code review","slug":"code-review","permalink":"https://java4all.cn/tags/code-review/"},{"name":"Java","slug":"Java","permalink":"https://java4all.cn/tags/Java/"},{"name":"管理","slug":"管理","permalink":"https://java4all.cn/tags/管理/"}]},{"title":"Seata 1.0版本整合SpringCloud教程","slug":"Seata1.0版本整合教程","date":"2020-01-04T16:00:00.000Z","updated":"2020-01-14T09:11:29.087Z","comments":true,"path":"2020/01/05/Seata1.0版本整合教程/","link":"","permalink":"https://java4all.cn/2020/01/05/Seata1.0版本整合教程/","excerpt":"","text":"seata 1.0入门教程技术选型及版本spring-cloud-starter-alibaba-seata spring-cloud-alibaba：1.5.1.RELEASE springcloud：Edgware.SR4 seata-all：1.0.0 springboot：1.5.4 mybatis-spring-boot-starter.version：2.0.0 java：jdk8 1.启动seata server下载包：https://github.com/seata/seata/releases 解压：tar -xzvf seata-server-1.0.0.tar.gz 修改配置： 1.配置registry.conf123456789101112131415161718192021222324252627[root@jr-test conf]# cat registry.conf //注册中心registry &#123; # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa type = \"eureka\" //注册中心类型 nacos &#123; serverAddr = \"localhost\" namespace = \"\" cluster = \"default\" &#125; eureka &#123; serviceUrl = \"http://192.xx.xx.xx:8761/eureka\" //注册中心地址 application = \"fsp_tx\" //tc注册时的名称 weight = \"1\" &#125; //......支持多种&#125;//配置中心config &#123; # file、nacos 、apollo、zk、consul、etcd3 type = \"file\" //配置中心类型 file &#123; name = \"file.conf\" // &#125; //......支持多种&#125; 2.配置file.conf123456789101112131415161718192021222324252627282930313233[root@jr-test conf]# cat file.confservice &#123; #transaction service group mapping vgroup_mapping.default = \"fsp_tx\" //事务分组，非常重要，client和tc一定要一致，default是个自定义的分组名称 #only support when registry.type=file, please don't set multiple addresses default.grouplist = \"127.0.0.1:8091\" #disable seata disableGlobalTransaction = false&#125;## transaction log store, only used in seata-serverstore &#123; ## store mode: file、db mode = \"db\" //事务日志存储模式 ## file store property file &#123; ## store location dir dir = \"sessionStore\" &#125; ## database store property db &#123; ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc. datasource = \"dbcp\" ## mysql/oracle/h2/oceanbase etc. db-type = \"mysql\" driver-class-name = \"com.mysql.jdbc.Driver\" url = \"jdbc:mysql://192.xx.xx.xx:3306/seata\" // tc的数据库,可自定义命名，对应就好 user = \"root\" password = \"xxx\" &#125;&#125; 3.建表全局事务会话信息由3块内容构成： 全局事务 global_table 分支事务 branch_table 全局锁 lock_table 建表语句在：https://github.com/seata/seata/tree/develop/script/server/db 4.启动tcbin目录下： 1nohup sh seata-server.sh -h xx.xx.xx.xx -p 8091 -m db -n 1 &amp; 这里是以nohup的方式后台启动，参数可选： -h: 注册到注册中心的ip -p: Server rpc 监听端口 -m: 全局事务会话信息存储模式，file、db，优先读取启动参数 -n: Server node，多个Server时，需区分各自节点，用于生成不同区间的transactionId，以免冲突 -e: 多环境配置参考 http://seata.io/en-us/docs/ops/multi-configuration-isolation.html 2.client端引入seata依赖目前有三种方式，相应的支持程度不同： 依赖 支持yml配置 实现xid传递 支持数据源自动代理 自动初始化GlobalTransactionScanner入口 seata-all 否 否 是 否 seata-spring-boot-starter 是 否 是 是 spring-cloud-alibaba-seata 否 是 是 是 不建议用户仅引入seata-all，需要自行实现的东西太多。 spring-cloud-alibaba-seata，2.1.0内嵌seata-all 0.7.1，2.1.1内嵌seata-all 0.9.0。建议排除掉，引入1.0； 我们这里以引入spring-cloud-alibaba-seata 依赖为例，下面仅展示与seata相关的依赖： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;properties&gt; &lt;spring-cloud.version&gt;Edgware.SR4&lt;/spring-cloud.version&gt; &lt;spring-cloud-alibaba.version&gt;1.5.1.RELEASE&lt;/spring-cloud-alibaba.version&gt; &lt;seata-version&gt;1.0.0&lt;/seata-version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!--seata-all--&gt; &lt;dependency&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;artifactId&gt;seata-all&lt;/artifactId&gt; &lt;version&gt;$&#123;seata-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--sca-seata--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--Spring Cloud--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--Spring Cloud Alibaba，包含seata-all 0.9,这里排除掉，换为1.0--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;seata-all&lt;/artifactId&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 3.client端引入配置文件seata server端和client端的脚本和配置，都汇总在这里，client端整合时，去找对应的文件复制过来修改。 https://github.com/seata/seata/tree/develop/script 1.修改bootstrap.yml添加事务分组 12345spring: cloud: alibaba: seata: tx-service-group: default //这个default是事务分组名称，与server端的事务分组名称保持一致 这个分组名称自定义，但是seata server端，client端要保持一致。 2.配置file.conf引入配置文件，并修改相关配置，由于有很多配置项，不是每个都需要去改一遍，这里只是改动少数，让你先能整合进去跑起来，其他的参数后面再自己调整。 file.conf 123456789101112131415161718192021//省略很多service &#123; #transaction service group mapping vgroup_mapping.default = \"fsp_tx\" //这个default是事务分组名称，与server端的事务分组名称保持一致 #only support when registry.type=file, please don't set multiple addresses default.grouplist = \"127.0.0.1:8091\" #degrade, current not support enableDegrade = false #disable seata disableGlobalTransaction = false&#125;client &#123; //省略很多 rm &#123; report.success.enable = true //一阶段成功后是否上报tc，这个配置可以提高性能 &#125; support &#123; # auto proxy the DataSource bean //数据源自动代理 spring.datasource.autoproxy = false &#125;&#125; 3.配置registry.conf注册中心和配置中心，都支持多种，按照自己的技术选型，修改对应的配置。 12345678910111213141516171819registry &#123; # file 、nacos 、eureka、redis、zk type = \"eureka\" eureka &#123; serviceUrl = \"http://192.xx.xx.xx:8761/eureka\" application = \"fsp_tx\" weight = \"1\" &#125; //省略&#125;config &#123; # file、nacos 、apollo、zk type = \"file\" file &#123; name = \"file.conf\" &#125; //省略&#125; 4.配置数据源头代理如果支持自动代理，那就开启配置就好，这里示例下使用mysql和mybatis时，如何自行代理数据源。 1234567891011121314151617181920212223242526272829303132333435363738394041424344package io.seata.sample;import com.alibaba.druid.pool.DruidDataSource;import io.seata.rm.datasource.DataSourceProxy;import javax.sql.DataSource;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.transaction.SpringManagedTransactionFactory;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.core.io.support.PathMatchingResourcePatternResolver;/** * 数据源代理 * @author IT云清 */@Configurationpublic class DataSourceConfiguration &#123; @Bean @ConfigurationProperties(prefix = \"spring.datasource\") public DataSource druidDataSource()&#123; DruidDataSource druidDataSource = new DruidDataSource(); return druidDataSource; &#125; @Primary @Bean(\"dataSource\") public DataSourceProxy dataSource(DataSource druidDataSource)&#123; return new DataSourceProxy(druidDataSource); &#125; @Bean public SqlSessionFactory sqlSessionFactory(DataSourceProxy dataSourceProxy)throws Exception&#123; SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSourceProxy); sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver() .getResources(\"classpath*:/mapper/*.xml\")); sqlSessionFactoryBean.setTransactionFactory(new SpringManagedTransactionFactory()); return sqlSessionFactoryBean.getObject(); &#125;&#125; 5.实现xid传递如果你引入的依赖和技术选型，没有实现xid传递等逻辑，你需要参考源码integration文件夹下的各种rpc实现 module。 https://github.com/seata/seata/tree/develop/integration 6.实现scanner入口如果你引入的依赖和技术选型，没有实现初始化GlobalTransactionScanner逻辑，可以自行实现如下： 1.SeataProperties.java 123456789101112@ConfigurationProperties(\"spring.cloud.alibaba.seata\")public class SeataProperties &#123; private String txServiceGroup; public SeataProperties() &#123; &#125; public String getTxServiceGroup() &#123; return this.txServiceGroup; &#125; public void setTxServiceGroup(String txServiceGroup) &#123; this.txServiceGroup = txServiceGroup; &#125;&#125; 2.初始化GlobalTransactionScanner 123456789101112131415161718192021222324252627282930313233343536373839404142package com.runlion.fsp.credit.seata.config;import com.runlion.fsp.credit.seata.SeataProperties;import io.seata.spring.annotation.GlobalTransactionScanner;import org.apache.commons.lang.StringUtils;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @author IT云清 */@Configuration@EnableConfigurationProperties(&#123;SeataProperties.class&#125;)public class GlobalTransactionAutoConfiguration &#123; private static final String APPLICATION_NAME_PREFIX = \"spring.application.name\"; private static final String DEFAULT_TX_SERVICE_GROUP_SUFFIX = \"-seata-service-group\"; private final ApplicationContext applicationContext; private final SeataProperties seataProperties; public GlobalTransactionAutoConfiguration( ApplicationContext applicationContext, SeataProperties seataProperties) &#123; this.applicationContext = applicationContext; this.seataProperties = seataProperties; &#125; /** * If there is no txServiceGroup,use the default * @return GlobalTransactionScanner the entrance */ @Bean public GlobalTransactionScanner globalTransactionScanner()&#123; String applicationName = this.applicationContext.getEnvironment().getProperty(APPLICATION_NAME_PREFIX); String txServiceGroup = seataProperties.getTxServiceGroup(); if(StringUtils.isEmpty(txServiceGroup))&#123; txServiceGroup = applicationName + DEFAULT_TX_SERVICE_GROUP_SUFFIX; this.seataProperties.setTxServiceGroup(txServiceGroup); &#125; return new GlobalTransactionScanner(applicationName,txServiceGroup); &#125;&#125; 7.建表如果要使用seata分布式事务，当前服务就需要建一张undolog表。 建表语句参考：https://github.com/seata/seata/tree/develop/script/client/at/db 8.使用 1.@GlobalTransaction 全局事务注解 2.@GlobalLock 防止脏读和脏写，又不想纳入全局事务管理时使用。（不需要rpc和xid传递等成本） 9.辅助信息如果发现数据不一致，可以参考下面的一些典型日志，或者查找关键字，比如Successfully begin global transaction，Successfully register branch xid = 。。。可以辅助你确认你的配置是否正确有效，各分支事务是否注册，纳入全局管理。1.client端如果正常启动，在server端会有如下日志，否则，请再检查配置：122019-12-31 15:38:44.170 INFO [ServerHandlerThread_1_500]io.seata.core.rpc.DefaultServerMessageListenerImpl.onRegRmMessage:123 -rm register success,message:RegisterRMRequest&#123;resourceIds='jdbc:mysql://116.xx.xx.xx/seata-account', applicationId='account-server', transactionServiceGroup='default'&#125;,channel:[id: 0xb58488ac, L:/192.xx.xx.xx:8091 - R:/192.xx.xx.xx:13641]2019-12-31 15:38:44.968 INFO [NettyServerNIOWorker_1_8]io.seata.core.rpc.DefaultServerMessageListenerImpl.onRegTmMessage:140 -checkAuth for client:192.xx.xx.xx:13644,vgroup:default,applicationId:account-server 2.全局事务提交成功,server端会有日志如下：1234567891011121314151617181920212223242019-12-31 16:00:31.209 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:205 -SeataMergeMessage timeout=60000,transactionName=fsp-create-order,clientIp:192.xx.xx.xx,vgroup:default2019-12-31 16:00:31.211 INFO [ServerHandlerThread_1_500]io.seata.server.coordinator.DefaultCore.begin:154 -Successfully begin global transaction xid = 192.xx.xx.xx:8091:20310756922019-12-31 16:00:31.253 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:205 -SeataMergeMessage xid=192.xx.xx.xx:8091:2031075692,branchType=AT,resourceId=jdbc:mysql://116.62.62.26/seata-order,lockKey=order:877,clientIp:192.xx.xx.xx,vgroup:default2019-12-31 16:00:31.257 INFO [ServerHandlerThread_1_500]io.seata.server.coordinator.DefaultCore.lambda$branchRegister$0:98 -Successfully register branch xid = 192.xx.xx.xx:8091:2031075692, branchId = 20310756942019-12-31 16:00:31.278 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:205 -SeataMergeMessage xid=192.xx.xx.xx:8091:2031075692,branchId=2031075694,resourceId=null,status=PhaseOne_Done,applicationData=null,clientIp:192.xx.xx.xx,vgroup:default2019-12-31 16:00:31.283 INFO [ServerHandlerThread_1_500]io.seata.server.coordinator.DefaultCore.branchReport:126 -Successfully branch report xid = 192.xx.xx.xx:8091:2031075692, branchId = 20310756942019-12-31 16:00:31.339 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:205 -SeataMergeMessage xid=192.xx.xx.xx:8091:2031075692,branchType=AT,resourceId=jdbc:mysql://116.62.62.26/seata-storage,lockKey=storage:1,clientIp:192.xx.xx.xx,vgroup:default2019-12-31 16:00:31.344 INFO [ServerHandlerThread_1_500]io.seata.server.coordinator.DefaultCore.lambda$branchRegister$0:98 -Successfully register branch xid = 192.xx.xx.xx:8091:2031075692, branchId = 20310756972019-12-31 16:00:31.363 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:205 -SeataMergeMessage xid=192.xx.xx.xx:8091:2031075692,branchId=2031075697,resourceId=null,status=PhaseOne_Done,applicationData=null,clientIp:192.xx.xx.xx,vgroup:default2019-12-31 16:00:31.366 INFO [ServerHandlerThread_1_500]io.seata.server.coordinator.DefaultCore.branchReport:126 -Successfully branch report xid = 192.xx.xx.xx:8091:2031075692, branchId = 20310756972019-12-31 16:00:32.237 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:205 -SeataMergeMessage xid=192.xx.xx.xx:8091:2031075692,branchType=AT,resourceId=jdbc:mysql://116.62.62.26/seata-account,lockKey=account:1,clientIp:192.xx.xx.xx,vgroup:default2019-12-31 16:00:32.242 INFO [ServerHandlerThread_1_500]io.seata.server.coordinator.DefaultCore.lambda$branchRegister$0:98 -Successfully register branch xid = 192.xx.xx.xx:8091:2031075692, branchId = 20310757012019-12-31 16:00:32.294 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:205 -SeataMergeMessage xid=192.xx.xx.xx:8091:2031075692,branchId=2031075701,resourceId=null,status=PhaseOne_Done,applicationData=null,clientIp:192.xx.xx.xx,vgroup:default2019-12-31 16:00:32.327 INFO [ServerHandlerThread_1_500]io.seata.server.coordinator.DefaultCore.branchReport:126 -Successfully branch report xid = 192.xx.xx.xx:8091:2031075692, branchId = 20310757012019-12-31 16:00:32.368 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:205 -SeataMergeMessage xid=192.xx.xx.xx:8091:2031075692,extraData=null,clientIp:192.xx.xx.xx,vgroup:default2019-12-31 16:00:32.775 INFO [AsyncCommitting_1]io.seata.server.coordinator.DefaultCore.doGlobalCommit:316 -Global[192.xx.xx.xx:8091:2031075692] committing is successfully done. 3.全局事务提交失败,server端会有日志如下：12345678910111213141516171819202019-12-31 16:16:50.327 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:205 -SeataMergeMessage timeout=60000,transactionName=fsp-create-order,clientIp:192.xx.xx.xx,vgroup:default2019-12-31 16:16:50.329 INFO [ServerHandlerThread_1_500]io.seata.server.coordinator.DefaultCore.begin:154 -Successfully begin global transaction xid = 192.xx.xx.xx:8091:20310757092019-12-31 16:16:50.408 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:205 -SeataMergeMessage xid=192.xx.xx.xx:8091:2031075709,branchType=AT,resourceId=jdbc:mysql://116.62.62.26/seata-order,lockKey=order:878,clientIp:192.xx.xx.xx,vgroup:default2019-12-31 16:16:50.412 INFO [ServerHandlerThread_1_500]io.seata.server.coordinator.DefaultCore.lambda$branchRegister$0:98 -Successfully register branch xid = 192.xx.xx.xx:8091:2031075709, branchId = 20310757112019-12-31 16:16:50.432 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:205 -SeataMergeMessage xid=192.xx.xx.xx:8091:2031075709,branchId=2031075711,resourceId=null,status=PhaseOne_Done,applicationData=null,clientIp:192.xx.xx.xx,vgroup:default2019-12-31 16:16:50.435 INFO [ServerHandlerThread_1_500]io.seata.server.coordinator.DefaultCore.branchReport:126 -Successfully branch report xid = 192.xx.xx.xx:8091:2031075709, branchId = 20310757112019-12-31 16:16:50.520 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:205 -SeataMergeMessage xid=192.xx.xx.xx:8091:2031075709,branchType=AT,resourceId=jdbc:mysql://116.62.62.26/seata-storage,lockKey=storage:1,clientIp:192.xx.xx.xx,vgroup:default2019-12-31 16:16:50.523 INFO [ServerHandlerThread_1_500]io.seata.server.coordinator.DefaultCore.lambda$branchRegister$0:98 -Successfully register branch xid = 192.xx.xx.xx:8091:2031075709, branchId = 20310757142019-12-31 16:16:50.541 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:205 -SeataMergeMessage xid=192.xx.xx.xx:8091:2031075709,branchId=2031075714,resourceId=null,status=PhaseOne_Done,applicationData=null,clientIp:192.xx.xx.xx,vgroup:default2019-12-31 16:16:50.544 INFO [ServerHandlerThread_1_500]io.seata.server.coordinator.DefaultCore.branchReport:126 -Successfully branch report xid = 192.xx.xx.xx:8091:2031075709, branchId = 20310757142019-12-31 16:16:52.569 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:205 -SeataMergeMessage xid=192.xx.xx.xx:8091:2031075709,extraData=null,clientIp:192.xx.xx.xx,vgroup:default2019-12-31 16:16:52.626 INFO [ServerHandlerThread_1_500]io.seata.server.coordinator.DefaultCore.doGlobalRollback:418 -Successfully rollback branch xid=192.xx.xx.xx:8091:2031075709 branchId=20310757142019-12-31 16:16:52.693 INFO [ServerHandlerThread_1_500]io.seata.server.coordinator.DefaultCore.doGlobalRollback:418 -Successfully rollback branch xid=192.xx.xx.xx:8091:2031075709 branchId=20310757112019-12-31 16:16:52.696 INFO [ServerHandlerThread_1_500]io.seata.server.coordinator.DefaultCore.doGlobalRollback:465 -Successfully rollback global, xid = 192.xx.xx.xx:8091:2031075709","categories":[{"name":"Seata","slug":"Seata","permalink":"https://java4all.cn/categories/Seata/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://java4all.cn/tags/Java/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://java4all.cn/tags/SpringCloud/"},{"name":"Seata","slug":"Seata","permalink":"https://java4all.cn/tags/Seata/"}]},{"title":"SpringCloud教程(Finchley版本)-08：eureka集群搭建","slug":"SpringCloud教程(Finchley版本)-08：eureka集群搭建","date":"2018-01-07T16:00:00.000Z","updated":"2020-01-14T11:38:51.337Z","comments":true,"path":"2018/01/08/SpringCloud教程(Finchley版本)-08：eureka集群搭建/","link":"","permalink":"https://java4all.cn/2018/01/08/SpringCloud教程(Finchley版本)-08：eureka集群搭建/","excerpt":"","text":"在eureka的服务治理设计中，所有的节点既是服务提供方，也是服务消费方，注册中心也不例外。eureka server的高可用集群，其实就是将自己作为服务向其他注册中心注册自己，这样几个节点的eureka就可以互相注册，实现服务清单的互相同步，达到高可用的效果。 本文，记录在本地搭建2个eureka服务，互相注册为一个集群，生产环境可以部署更多的节点。示例中两个项目分别为eureka-server，port为8761，和eureka-server1，port为8762。这里列出重点步骤。 1.引入依赖 eureka-server12345&lt;!--eureka-server--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt; 2.启动类 eureka-server添加注解 1@EnableEurekaServer 3.配置文件 eureka-servereureka-server注册到 eureka-server2上，并且，register-with-eureka: true， fetch-registry: true，两个参数，需要设置为true，让他们可以互相注册，同步服务清单；由于这里我使用的ip来做地址，而不是服务名，所以需要打开prefer-ip-address: true。 123456789101112131415161718server: port: 8761spring: application: name: eureka-servereureka: instance: hostname: peer1 prefer-ip-address: true# 允许使用ip地址来定义注册中心的地址，默认是false client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://127.0.0.1:8762/eureka/ server: enable-self-preservation: false# 默认情况下，eureka间隔60s将服务清单中没有续约的服务剔除（默认90s内没有续约），本地测试，关闭保护机制，直接让它实时剔除 4.引入依赖 eureka-server212345&lt;!--eureka-server--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt; 5.启动类 eureka-server2添加注解 1@EnableEurekaServer 6.配置文件 eureka-server2eureka-server2注册到 eureka-server上，并且，register-with-eureka: true， fetch-registry: true，两个参数，需要设置为true，让他们可以互相注册，同步服务清单；由于这里我使用的ip来做地址，而不是服务名，所以需要打开prefer-ip-address: true。 123456789101112131415161718server: port: 8762spring: application: name: eureka-servereureka: instance: hostname: peer2 prefer-ip-address: true# 允许使用ip地址来定义注册中心的地址，默认是false client: register-with-eureka: true fetch-registry: true service-url: defaultZone: http://127.0.0.1:8761/eureka/ server: enable-self-preservation: false# 默认情况下，eureka间隔60s将服务清单中没有续约的服务剔除（默认90s内没有续约），本地测试，关闭保护机制，直接让它实时剔除 7.服务注册在其他服务向eureka集群注册时，可以只注册到一个节点，也可以向多节点注册。因为集群中节点会自动同步服务列表，所以上述2种方式均可。这里给出一个示例，比如company-server，向注册中心注册，写法如下： 1234eureka: client: service-url: default: http://127.0.0.1:8761/eureka 可以发现，注册到eureka集群，和注册到单体eureka上，对于注册者而言，是相同的，无需额外处理。当然，也可以如下，向多个节点注册： 1234eureka: client: service-url: default: http://127.0.0.1:8761/eureka，http://127.0.0.1:8762/eureka 这里采用第一种写法，注册完后，启动eureka集群（由于启动有先后，会报错，因为互相注册，对方可能还没起来，等都起来了，就好了），然后再启动company-server，访问2个注册中心，结果如下：可以看到，尽管我们只向eureka-server注册了，但是eureka-server2也可以看到这个服务。","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://java4all.cn/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://java4all.cn/tags/SpringCloud/"},{"name":"eureka","slug":"eureka","permalink":"https://java4all.cn/tags/eureka/"}]},{"title":"SpringCloud教程(Finchley版本)-07：网关（Zuul）","slug":"SpringCloud教程(Finchley版本)-07：网关（Zuul）","date":"2018-01-06T16:00:00.000Z","updated":"2020-01-14T11:35:04.273Z","comments":true,"path":"2018/01/07/SpringCloud教程(Finchley版本)-07：网关（Zuul）/","link":"","permalink":"https://java4all.cn/2018/01/07/SpringCloud教程(Finchley版本)-07：网关（Zuul）/","excerpt":"","text":"在微服务架构中，后端服务往往不会直接开放给调用端，而是通过一个网关根据请求的url，路由到相应的服务。当添加网关后，在第三方调用端和服务提供方之间就创建了一面墙，这面墙直接与调用方通信进行权限控制，后将请求均衡分发给后台服务端。在Spring Cloud体系中， Spring Cloud Zuul就起到了网关的作用，它可以提供动态路由，监控，弹性，安全等的边缘服务。本文示例一下zuul的简单使用，主要分为以下几个步骤： 1.创建项目 2.引入依赖 3.修改配置文件 4.添加启动注解 5.自定义Filter 6.启动项目，测试 1.创建项目新建一个Springboot项目zuul_server1。 2.引入依赖1234567891011&lt;!--eureka client--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--zuul--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;&lt;/dependency&gt; 1234567891011&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 1&lt;spring-cloud.version&gt;Finchley.SR2&lt;/spring-cloud.version&gt; 3.修改配置文件zuul需要注册到eureka上，然后我们配置路由，配置指定类型的请求路由到指定的服务上：当请求path是以/api-a/开头的，就转发到feign-server1服务上，当请求path是以/api-b/开头的，就转发到service-ribbon服务上，如果有其他路由，在routes下继续添加即可： 1234567891011121314151617181920server: port: 8018spring: application: name: zuul-servereureka: client: service-url: default: http://localhost:8761/eurekazuul: routes: apia: path: /api-a/** serviceId: feign-server1 apib: path: /api-b/** serviceId: service-ribbon 4.添加启动注解1234567891011//开启zuul的功能@EnableZuulProxy@EnableEurekaClient@EnableDiscoveryClient@SpringBootApplicationpublic class ZuulServer1Application &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulServer1Application.class, args); &#125;&#125; 5.自定义Filterzuul提供的功能，不仅仅是路由，我们还可以把所有的请求，在网关这一层，做个安全的校验，过滤，或者，也可以做一些其的处理。这里做个简单的token是否为空的校验，我们需要用到Filter. Filter是Zuul的核心，用来实现对外服务的控制。Filter的生命周期有4个，分别是“PRE”、“ROUTING”、“POST”、“ERROR”,Zuul大部分功能都是通过过滤器来实现的，这些过滤器类型对应于请求的典型生命周期。 PRE： 这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选择请求的微服务、记录调试信息等。 ROUTING：这种过滤器将请求路由到微服务。这种过滤器用于构建发送给微服务的请求，并使用Apache HttpClient或Netfilx Ribbon请求微服务。 POST：这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端等。 ERROR：在其他阶段发生错误时执行该过滤器。 除了默认的过滤器类型，Zuul还允许我们创建自定义的过滤器类型。例如，我们可以定制一种STATIC类型的过滤器，直接在Zuul中生成响应，而不将请求转发到后端的微服务。 此部分更具体的内容，可以参考：click here 我们来自定义一个Filter，用来校验token是否为空，自定义Filter，需要继承ZuulFilter，并实现其中的一些方法。我们在run中，多请求做个校验，当token为空时，就直接返回，不再向后端服务转发。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Componentpublic class RequestFilter extends ZuulFilter&#123; private static Logger logger = LoggerFactory.getLogger(RequestFilter.class); /** * pre 路由之前 * routing 路由之时 * post 路由之后 * error 发送错误调用 * @return */ @Override public String filterType() &#123; return &quot;pre&quot;; &#125; /**过滤的顺序，数字越小越先执行*/ @Override public int filterOrder() &#123; return 0; &#125; /**这里可以写逻辑判断，是否要过滤，true表示过滤，false表示不过滤*/ @Override public boolean shouldFilter() &#123; return true; &#125; /**filter需要执行的具体操作*/ @Override public Object run() throws ZuulException &#123; RequestContext currentContext = RequestContext.getCurrentContext(); HttpServletRequest request = currentContext.getRequest(); String token = request.getParameter(&quot;token&quot;); if(StringUtils.isEmpty(token))&#123; logger.warn(&quot;=======&gt;token is empty&quot;); currentContext.setSendZuulResponse(false);//不对其进行路由 currentContext.setResponseStatusCode(401); try &#123; currentContext.getResponse().getWriter().write(&quot;token is empty&quot;); &#125;catch (Exception ex)&#123; ex.printStackTrace(); &#125; &#125;else &#123; currentContext.setSendZuulResponse(true);//进行路由 currentContext.setResponseStatusCode(200); &#125; return null; &#125;&#125; 6.启动项目，测试我们需要启动前几篇文章创建的几个服务，然后启动本文的服务。然后先访问:http://localhost:8018/api-a/getCompany?id=234, 这个请求中没有带token参数的，查看结果： 会发现，这个请求，并没有到后台服务，直接在网关这里就被拦截返回了。我们再请求一下：http://localhost:8018/api-b/getCompany?id=234&amp;token=qweqew， 查看结果：由于带的有token，请求顺利的到了后台，请求到了指定服务。 完整源码参考：https://github.com/myJava4all/springcloudfinchley","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://java4all.cn/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://java4all.cn/tags/SpringCloud/"},{"name":"Zuul","slug":"Zuul","permalink":"https://java4all.cn/tags/Zuul/"}]},{"title":"SpringCloud教程(Finchley版本)-06：断路器（Hystrix-Feign）","slug":"SpringCloud教程(Finchley版本)-06：断路器（Hystrix-Feign）","date":"2018-01-05T16:00:00.000Z","updated":"2020-01-14T11:16:43.603Z","comments":true,"path":"2018/01/06/SpringCloud教程(Finchley版本)-06：断路器（Hystrix-Feign）/","link":"","permalink":"https://java4all.cn/2018/01/06/SpringCloud教程(Finchley版本)-06：断路器（Hystrix-Feign）/","excerpt":"","text":"在微服务系统中，我们把系统拆分成了很多小的服务，各个服务之间通过不同的方式进行依赖和调用，为了保证服务的高可用性，单个服务通常会集群部署，此时，许多服务由于各种问题可能会调用失败，比如超时、异常等。如何能够保证在一个依赖出问题的情况下，不会出现故障传播，导致整体服务失败，这个就是Hystrix需要做的事情。Hystrix提供了熔断、隔离、Fallback、cache、监控等功能，能够在一个、或多个依赖同时出现问题时保证系统依然可用。 本文介绍如何结合上一文SpringCloud教程(Finchley版本)-05：负载均衡（Feign），使用Hystrix来实现熔断功能。主要分为以下几个步骤： 1.创建项目 2.引入依赖 3.修改配置文件 4.添加启动注解 5.跨服务调用 6.熔断实现 7.启动项目，测试 1.创建项目新建一个Springboot项目feign_server1。 2.引入依赖1234567891011&lt;!--eureka-client--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--feign--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 1234567891011&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 1&lt;spring-cloud.version&gt;Finchley.SR2&lt;/spring-cloud.version&gt; 3.修改配置文件123456789101112server: port: 8015spring: application: name: feign-server1eureka: client: service-url: default: http://localhost:8761/eureka/feign: hystrix: enabled: true 4.添加启动注解启动类添加@EnableFeignClients，开启Feign的负载均衡功能 12345678910//开启Feign的负载均衡功能@EnableFeignClients@EnableEurekaClient@SpringBootApplicationpublic class FeignServer1Application &#123; public static void main(String[] args) &#123; SpringApplication.run(FeignServer1Application.class, args); &#125;&#125; 5.跨服务调用写个简单的接口方法来调用。 5.1controller123456789101112131415@RestController//@RequestMapping(value = &quot;feign&quot;)public class FeignController &#123; //编译报错，可以不用管，程序启动时才会注入此bean @Autowired FeignService feignService; @GetMapping(&quot;getCompany&quot;) public String getCompany(String id)&#123; String company = feignService.getCompany(id); System.out.println(company); return company; &#125;&#125; 5.2service通过@FeignClient来指定我们调用哪个服务，前面启动了两个服务，都为company-server，feign会通过服务名来调用服务。 12345678//通过此注解，来指定调用哪个服务@FeignClient(value = &quot;company-server&quot;)public interface FeignService &#123; /**调用company-server服务中的company/get接口*/ @GetMapping(value = &quot;/company/get&quot;) String getCompany(@RequestParam(value = &quot;id&quot;)String id);&#125; 6.熔断实现Feign中实现熔断功能非常简单，只需要在上面的@FeignClient中指定fallback的实现即可，然后在接口的实现类中添加熔断逻辑。 6.1service只是在上面5.2中做了简单的修改 123456789//通过此注解，来指定调用哪个服务//如果开启了断路器，只需要添加fallback，在此接口实现类中添加熔断方法即可@FeignClient(value = &quot;company-server&quot;,fallback = FeignServiceImpl.class)public interface FeignService &#123; /**调用company-server服务中的company/get接口*/ @GetMapping(value = &quot;/company/get&quot;) String getCompany(@RequestParam(value = &quot;id&quot;)String id);&#125; 6.2serviceImpl添加断路器的实现逻辑，实现熔断方法。 123456789@Componentpublic class FeignServiceImpl implements FeignService&#123; //熔断方法 @Override public String getCompany(String id) &#123; return &quot;服务出错，返回指定企业信息：华为&quot;+id; &#125;&#125; 7.启动项目，测试启动项目，然后访问接口http://localhost:8015/getCompany?id=36，可以看到服务会自动负载到两台服务上。 如果挂掉8011服务，可以看到访问结果如下： 下一篇：SpringCloud教程(Finchley版本)-07：网关（zuul）完整源码参考：https://github.com/myJava4all/springcloudfinchley","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://java4all.cn/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://java4all.cn/tags/SpringCloud/"},{"name":"Feign","slug":"Feign","permalink":"https://java4all.cn/tags/Feign/"},{"name":"Hystrix","slug":"Hystrix","permalink":"https://java4all.cn/tags/Hystrix/"}]},{"title":"SpringCloud教程(Finchley版本)-05：负载均衡（Feign）","slug":"SpringCloud教程(Finchley版本)-05：负载均衡（Feign）","date":"2018-01-04T16:00:00.000Z","updated":"2020-01-14T11:12:02.419Z","comments":true,"path":"2018/01/05/SpringCloud教程(Finchley版本)-05：负载均衡（Feign）/","link":"","permalink":"https://java4all.cn/2018/01/05/SpringCloud教程(Finchley版本)-05：负载均衡（Feign）/","excerpt":"","text":"本文介绍使用Feign实现负载均衡，主要分为以下几个步骤： 1.创建项目 2.引入依赖 3.修改配置文件 4.添加启动注解 5.跨服务调用 6.启动项目，测试 1.创建项目新建一个Springboot项目feign_server1。 2.引入依赖1234567891011&lt;!--eureka-client--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--feign--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 1234567891011&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 1&lt;spring-cloud.version&gt;Finchley.SR2&lt;/spring-cloud.version&gt; 3.修改配置文件123456789101112server: port: 8015spring: application: name: feign-server1eureka: client: service-url: default: http://localhost:8761/eureka/feign: hystrix: enabled: true 4.添加启动注解启动类添加@EnableFeignClients，开启Feign的负载均衡功能 12345678910//开启Feign的负载均衡功能@EnableFeignClients@EnableEurekaClient@SpringBootApplicationpublic class FeignServer1Application &#123; public static void main(String[] args) &#123; SpringApplication.run(FeignServer1Application.class, args); &#125;&#125; 5.跨服务调用写个简单的接口方法来调用。 5.1controller123456789101112131415@RestController//@RequestMapping(value = &quot;feign&quot;)public class FeignController &#123; //编译报错，可以不用管，程序启动时才会注入此bean @Autowired FeignService feignService; @GetMapping(&quot;getCompany&quot;) public String getCompany(String id)&#123; String company = feignService.getCompany(id); System.out.println(company); return company; &#125;&#125; 5.2service通过@FeignClient来指定我们调用哪个服务，前面启动了两个服务，都为company-server，feign会通过服务名来调用服务。 12345678//通过此注解，来指定调用哪个服务@FeignClient(value = &quot;company-server&quot;)public interface FeignService &#123; /**调用company-server服务中的company/get接口*/ @GetMapping(value = &quot;/company/get&quot;) String getCompany(@RequestParam(value = &quot;id&quot;)String id);&#125; 6.启动项目，测试启动项目，然后访问接口http://localhost:8015/getCompany?id=36，可以看到服务会自动负载到两台服务上。 下一篇：SpringCloud教程(Finchley版本)-06：断路器（Hystrix-Feign）完整源码参考：https://github.com/myJava4all/springcloudfinchley","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://java4all.cn/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://java4all.cn/tags/SpringCloud/"},{"name":"Feign","slug":"Feign","permalink":"https://java4all.cn/tags/Feign/"}]},{"title":"SpringCloud教程(Finchley版本)-04：断路器（Hystrix-Ribbon）","slug":"SpringCloud教程(Finchley版本)-04：断路器（Hystrix-Ribbon）","date":"2018-01-03T16:00:00.000Z","updated":"2020-01-14T11:07:12.063Z","comments":true,"path":"2018/01/04/SpringCloud教程(Finchley版本)-04：断路器（Hystrix-Ribbon）/","link":"","permalink":"https://java4all.cn/2018/01/04/SpringCloud教程(Finchley版本)-04：断路器（Hystrix-Ribbon）/","excerpt":"","text":"在微服务系统中，我们把系统拆分成了很多小的服务，各个服务之间通过不同的方式进行依赖和调用，为了保证服务的高可用性，单个服务通常会集群部署，此时，许多服务由于各种问题可能会调用失败，比如超时、异常等。如何能够保证在一个依赖出问题的情况下，不会出现故障传播，导致整体服务失败，这个就是Hystrix需要做的事情。Hystrix提供了熔断、隔离、Fallback、cache、监控等功能，能够在一个、或多个依赖同时出现问题时保证系统依然可用。 本文介绍如何结合上一文SpringCloud教程(Finchley版本)-03：负载均衡（Ribbon），使用Hystrix来实现断路器功能。主要分为以下几个步骤： 1.创建项目 2.引入依赖 3.修改配置文件 4.添加启动注解 5.注入模板类 6.跨服务调用 7.启动项目，测试 1.创建项目新建一个Springboot项目hystrix_ribbon_server1。 2.引入依赖1234567891011121314151617&lt;!--eureka-client--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--eureka ribbon--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--hystrix--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 123456789101112&lt;!--springcloud依赖管理--&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 1&lt;spring-cloud.version&gt;Finchley.SR2&lt;/spring-cloud.version&gt; 3.修改配置文件123456789server: port: 8017spring: application: name: hystrix-ribbon-servereureka: client: service-url: defaultZone: http://localhost:8761/eureka/ 4.添加启动注解5.注入模板类4.5步骤和前文的Ribbon一样。 1234567891011121314151617181920212223242526272829package com.java4all.hystrix_ribbon_server1;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.cloud.netflix.hystrix.EnableHystrix;import org.springframework.context.annotation.Bean;import org.springframework.web.client.RestTemplate;@EnableHystrix@EnableEurekaClient@SpringBootApplicationpublic class HystrixRibbonServer1Application &#123; /** * * @Bean ： 注入一个名为restTemplate的bean * @LoadBalanced ：表明这个 restTemplate 开启了负载均衡的功能 * * */ @Bean @LoadBalanced RestTemplate restTemplate()&#123;return new RestTemplate();&#125; public static void main(String[] args) &#123; SpringApplication.run(HystrixRibbonServer1Application.class, args); &#125;&#125; 6.跨服务调用写一套简单的业务代码，然后调用前面创建的company-server服务提供的接口。 6.1 controller1234567891011121314@RestController@RequestMapping(value = &quot;hrs&quot;)public class HrsController &#123; @Autowired private HrsService hrsService; @GetMapping(value = &quot;getCompany&quot;) public String getCompany(String id)&#123; String company = hrsService.getCompany(id); System.out.println(company); return company; &#125;&#125; 6.2 service1234public interface RibbonService &#123; String getCompany(String id);&#125; 6.3 serviceImpl在serviceImpl实现类中，我们引入前面的RestTemplate模板类，来跨服务调用，并开启了负载均衡功能。 在getCompany方法上添加@HystrixCommand注解。该注解对该方法创建了熔断器的功能，并指定了fallbackMethod熔断方法erroCompany，熔断方法直接返回了一个字符串 12345678910111213141516171819202122@Servicepublic class HrsServiceImpl implements HrsService&#123; //启动类中注入了此模板，并且开启了负载均衡功能 @Autowired RestTemplate restTemplate; //给方法添加熔断器的功能，并指定熔断方法 @HystrixCommand(fallbackMethod = &quot;erroCompany&quot;) @Override public String getCompany(String id) &#123; //程序名替代服务地址，ribbon会根据服务名自动选择服务实例 String company = restTemplate .getForObject(&quot;http://company-server/company/get?id=&quot; + id, String.class); return company; &#125; /**熔断方法*/ public String erroCompany(String id)&#123; return &quot;服务出错，返回默认企业：&quot;+id; &#125;&#125; 7.启动项目，测试此时，启动项目，访问http://localhost:8017/hrs/getCompany?id=234，我们这个项目的接口会去调用前面启动的企业服务，由于企业服务启动了两台：8011，8014，那么，通过ribbon负载均衡后，会分发到两台服务上。如下：当我们把8011挂掉后，此时，由于eureka更新服务列表默认时间为30s，这之间，如果请求落在8011上，那么，就会调用熔断方法，返回指定的结果，如下： 下一篇：SpringCloud教程(Finchley版本)-05：负载均衡（Feign）完整源码参考：https://github.com/myJava4all/springcloudfinchley","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://java4all.cn/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://java4all.cn/tags/SpringCloud/"},{"name":"Ribbon","slug":"Ribbon","permalink":"https://java4all.cn/tags/Ribbon/"},{"name":"Hystrix","slug":"Hystrix","permalink":"https://java4all.cn/tags/Hystrix/"}]},{"title":"SpringCloud教程(Finchley版本)-03：负载均衡（Ribbon）","slug":"SpringCloud教程(Finchley版本)-03：负载均衡（Ribbon）","date":"2018-01-02T16:00:00.000Z","updated":"2020-01-14T11:03:04.751Z","comments":true,"path":"2018/01/03/SpringCloud教程(Finchley版本)-03：负载均衡（Ribbon）/","link":"","permalink":"https://java4all.cn/2018/01/03/SpringCloud教程(Finchley版本)-03：负载均衡（Ribbon）/","excerpt":"","text":"Spring Cloud Ribbon是一个基于Http和TCP的客服端负载均衡工具，它是基于Netflix Ribbon实现的。它是一个工具类框架，不像服务注册中心、配置中心、API网关那样独立部署，但是它几乎存在于每个微服务的基础设施中。微服务间的调用，API网关的请求转发等，都是通过Ribbon来实现的，包括后面要介绍的Feign，也是基于Ribbon实现的工具。 本文介绍如何使用Ribbon来实现客户端的负载均衡。主要分为以下几个步骤： 1.创建项目 2.引入依赖 3.修改配置文件 4.添加启动注解 5.注入模板类 6.跨服务调用 7.启动项目，测试 1.创建项目新建一个Springboot项目ribbon_server1。 2.引入依赖ribbon依赖和eureka依赖 1234567891011&lt;!--eureka-client--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--eureka ribbon--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;&lt;/dependency&gt; springcloud依赖，在 标签外面： 123456789101112&lt;!--spring-cloud依赖--&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 1&lt;spring-cloud.version&gt;Finchley.SR2&lt;/spring-cloud.version&gt; 3.修改配置文件123456789server: port: 8016spring: application: name: service-ribboneureka: client: service-url: defaultZone: http://localhost:8761/eureka/ 4.添加启动注解启动类中，照例要给注册为一个eurekaClient，添加@EnableEurekaClient 5.注入模板类在启动类中，注入RestTemplate模板到容器中，该对象会使用Ribbon的自动化配置，当开启了@LoadBalanced后，可以开启客户端负载均衡。 123456789101112131415161718@EnableEurekaClient@SpringBootApplicationpublic class RibbonServer1Application &#123; /** * * @Bean ： 注入一个名为restTemplate的bean * @LoadBalanced ：表明这个 restTemplate 开启了负载均衡的功能 * * */ @Bean @LoadBalanced RestTemplate restTemplate()&#123;return new RestTemplate();&#125; public static void main(String[] args) &#123; SpringApplication.run(RibbonServer1Application.class, args); &#125;&#125; 6.跨服务调用写一套简单的业务代码，然后调用前面创建的company-server服务提供的接口。 6.1 controller1234567891011121314@RestController//@RequestMapping(value = &quot;ribbon&quot;)public class RibbonController &#123; @Autowired private RibbonService ribbonService; @GetMapping(value = &quot;getCompany&quot;) public String getCompany(String id)&#123; String company = ribbonService.getCompany(id); System.out.println(company); return company; &#125;&#125; 6.2 service1234public interface RibbonService &#123; String getCompany(String id);&#125; 6.3 serviceImpl在serviceImpl实现类中，我们引入前面的RestTemplate模板类，来跨服务调用，并开启了负载均衡功能。 123456789101112131415@Servicepublic class RibbonServiceImpl implements RibbonService&#123; //启动类中注入了此模板，并且开启了负载均衡功能 @Autowired RestTemplate restTemplate; //程序名替代服务地址，ribbon会根据服务名自动选择服务实例 @Override public String getCompany(String id) &#123; String company = restTemplate .getForObject(&quot;http://company-server/company/get?id=&quot; + id, String.class); return company; &#125;&#125; 7.启动项目，测试启动项目，访问这个项目的接口http://localhost:8016/getCompany?id=1234，会发现，这个服务调用了company-server服务提供的接口，并且，接口在两个相同的服务间自动切换，也就是，实现了负载均衡的功能。 不断刷新接口，可以看到服务方发生了切换，如下：当然，restTemplate提供了多种方法，get,post,delete,put等方法，这里只是示例了一种。 下一篇：SpringCloud教程(Finchley版本)-04：断路器（Hystrix-Ribbon）完整源码参考：https://github.com/myJava4all/springcloudfinchley","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://java4all.cn/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://java4all.cn/tags/SpringCloud/"},{"name":"Ribbon","slug":"Ribbon","permalink":"https://java4all.cn/tags/Ribbon/"}]},{"title":"SpringCloud教程(Finchley版本)-02：服务消费者","slug":"SpringCloud教程(Finchley版本)-02：服务消费者","date":"2018-01-01T16:00:00.000Z","updated":"2020-01-14T11:02:54.926Z","comments":true,"path":"2018/01/02/SpringCloud教程(Finchley版本)-02：服务消费者/","link":"","permalink":"https://java4all.cn/2018/01/02/SpringCloud教程(Finchley版本)-02：服务消费者/","excerpt":"","text":"本文，讲述如何将一个服务注册到eureka注册中心，主要分为以下几个步骤： 1.新建项目 2.引入eureka依赖 3.添加注解 4.修改配置文件 5.新建一个controller，提供一个服务接口 6.启动项目 由于后续需要演示负载均衡，这里会创建两个项目company_server1，company_server2，这两个项目提供完全相同的服务，注册到注册中心时，使用相同的服务名称company-server，由于是两个服务，所以项目的端口是不同的，其他相同。具体步骤如下：1.新建项目新建一个SpringBoot项目company_server1。 2.引入eureka依赖eureka-client依赖： 12345&lt;!--eureka client--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; springcloud依赖，在 标签外面： 123456789101112&lt;!--springcloud依赖管理--&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 1&lt;spring-cloud.version&gt;Finchley.SR2&lt;/spring-cloud.version&gt; 3.添加注解在启动类添加注解@EnableEurekaClient，将项目启动为一个以eureka做注册中心的服务。 12345678@EnableEurekaClient@SpringBootApplicationpublic class CompanyServer1Application &#123; public static void main(String[] args) &#123; SpringApplication.run(CompanyServer1Application.class, args); &#125;&#125; 4.修改配置文件123456789server: port: 8011spring: application: name: company-servereureka: client: service-url: defaultZone: http://localhost:8761/eureka name: company-server，就是把此项目注册到注册中心时，服务名为company-server，后面其他项目，通过这个服务名称，就能找到这个服务，而不需要通过ip:port。 5.新建一个controller，提供一个服务接口我们新建一个controller包，下面建一个CompanyController，里面写一个服务接口，对外提供服务，代码如下: 123456789101112@RestController@RequestMapping(&quot;company&quot;)public class CompanyController &#123; @Value(&quot;$&#123;server.port&#125;&quot;) String port; @GetMapping(&quot;get&quot;) public String getCompany(Integer id)&#123; return &quot;port:&quot;+port+&quot;,企业信息为：阿里巴巴&quot;+id; &#125;&#125; 6.启动项目启动项目，会发现项目注册到了注册中心上：访问接口http://localhost:8011/company/get?id=2，发现接口也可以提供服务。然后我们再写一个相同的服务，步骤和上面一样，端口改为8014，注册时，服务名和上面一样，也是company-server，提供相同的服务，方便后面演示负载均衡。 下一篇：SpringCloud教程(Finchley版本)-03：负载均衡（Ribbon）完整源码参考：https://github.com/myJava4all/springcloudfinchley","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://java4all.cn/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://java4all.cn/tags/SpringCloud/"}]},{"title":"SpringCloud教程(Finchley版本)-01：服务注册与发现（Eureka）","slug":"SpringCloud教程(Finchley版本)-01：服务注册与发现（Eureka）","date":"2017-12-31T16:00:00.000Z","updated":"2020-01-14T11:02:46.473Z","comments":true,"path":"2018/01/01/SpringCloud教程(Finchley版本)-01：服务注册与发现（Eureka）/","link":"","permalink":"https://java4all.cn/2018/01/01/SpringCloud教程(Finchley版本)-01：服务注册与发现（Eureka）/","excerpt":"","text":"本文，讲述如何启动一个项目作为eureka注册中心，主要分为以下几个步骤： 1.新建项目 2.引入eureka依赖 3.添加注解 4.修改配置文件 5.启动项目 1.新建项目（注册中心）新建一个SpringBoot项目eureka_server，作为注册中心，后续的其他项目，都注册在这个注册中心上面。 2.引入eureka依赖这里和普通springboot项目相比，主要就是需要多引入两个依赖：eureka的，spring-cloud相关的。 eureka-server依赖： 12345&lt;!--eureka-server--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt; springcloud依赖，在 标签外面： 123456789101112&lt;!--spring-cloud依赖--&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 1&lt;spring-cloud.version&gt;Finchley.SR2&lt;/spring-cloud.version&gt; 3.添加注解在项目的启动类中，添加@EnableEurekaServer注解，将此项目启动为注册中心。 123456789//启动为一个注册中心@EnableEurekaServer@SpringBootApplicationpublic class EurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServerApplication.class, args); &#125;&#125; 4.修改配置文件在配置文件中配置注册中心相关信息 12345678910111213server: port: 8761spring: application: name: eureka-servereureka: instance: hostname: localhost client: register-with-eureka: false fetch-registry: false service-url: defultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 解释一下： register-with-eureka: false，是否注册到eureka服务器，由于自己就是eureka服务器，没有必要注册自身。 fetch-registry: false：是否从eureka服务器获取注册信息，这里也没必要。 defultZone：设置eureka服务器所在地址，注册服务和查询服务都依靠这个地址。 5.启动项目启动项目，访问http://localhost:8761/，会看到如下画面，说明注册中心启动成功，后续当有服务注册进来时，都会在这里显示。 下一篇：SpringCloud教程(Finchley版本)-02：服务消费者完整源码参考：https://github.com/myJava4all/springcloudfinchley","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://java4all.cn/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://java4all.cn/tags/SpringCloud/"},{"name":"Eureka","slug":"Eureka","permalink":"https://java4all.cn/tags/Eureka/"}]},{"title":"SpringCloud教程(Finchley版本)-00：什么是SpringCloud","slug":"SpringCloud教程(Finchley版本)-00：什么是SpringCloud","date":"2017-12-31T16:00:00.000Z","updated":"2020-01-14T11:43:08.460Z","comments":true,"path":"2018/01/01/SpringCloud教程(Finchley版本)-00：什么是SpringCloud/","link":"","permalink":"https://java4all.cn/2018/01/01/SpringCloud教程(Finchley版本)-00：什么是SpringCloud/","excerpt":"","text":"SpringCloud是什么，能干什么，有什么优势，这几个问题，网上有很多资料，这里就不再单独整理，这里转载一篇,有适当修改。 本文转载自纯洁的微笑的博客：大话Spring Cloud Spring Cloud是什么Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。 微服务是可以独立部署、水平扩展、独立访问（或者有独立的数据库）的服务单元，springcloud就是这些微服务的大管家，采用了微服务这种架构之后，项目的数量会非常多，springcloud做为大管家需要管理好这些微服务，自然需要很多小弟来帮忙。 主要的小弟有：Spring Cloud Config、Spring Cloud Netflix（Eureka、Hystrix、Zuul、Archaius…）、Spring Cloud Bus、Spring Cloud for Cloud Foundry、Spring Cloud Cluster、Spring Cloud Consul、Spring Cloud Security、Spring Cloud Sleuth、Spring Cloud Data Flow、Spring Cloud Stream、Spring Cloud Task、Spring Cloud Zookeeper、Spring Cloud Connectors、Spring Cloud Starters、Spring Cloud CLI，每个小弟身怀独门绝技武功高强下面来做一一介绍。 核心成员Spring Cloud Netflix这可是个大boss，地位仅次于老大，老大各项服务依赖与它，与各种Netflix OSS组件集成，组成微服务的核心，它的小弟主要有Eureka, Hystrix, Zuul, Archaius… 太多了 Netflix Eureka服务中心，云端服务发现，一个基于 REST 的服务，用于定位服务，以实现云端中间层服务发现和故障转移。这个可是springcloud最牛鼻的小弟，服务中心，任何小弟需要其它小弟支持什么都需要从这里来拿，同样的你有什么独门武功的都赶紧过报道，方便以后其它小弟来调用；它的好处是你不需要直接找各种什么小弟支持，只需要到服务中心来领取，也不需要知道提供支持的其它小弟在哪里，还是几个小弟来支持的，反正拿来用就行，服务中心来保证稳定性和质量。 Netflix Hystrix熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。比如突然某个小弟生病了，但是你还需要它的支持，然后调用之后它半天没有响应，你却不知道，一直在等等这个响应；有可能别的小弟也正在调用你的武功绝技，那么当请求多之后，就会发生严重的阻塞影响老大的整体计划。这个时候Hystrix就派上用场了，当Hystrix发现某个小弟不在状态不稳定立马马上让它下线，让其它小弟来顶上来，或者给你说不用等了这个小弟今天肯定不行，该干嘛赶紧干嘛去别在这排队了。 Netflix ZuulZuul 是在云平台上提供动态路由,监控,弹性,安全等边缘服务的框架。Zuul 相当于是设备和 Netflix 流应用的 Web 网站后端所有请求的前门。当其它门派来找大哥办事的时候一定要先经过zuul,看下有没有带刀子什么的给拦截回去，或者是需要找那个小弟的直接给带过去。 Netflix Archaius配置管理API，包含一系列配置管理API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。可以实现动态获取配置， 原理是每隔60s（默认，可配置）从配置源读取一次内容，这样修改了配置文件后不需要重启服务就可以使修改后的内容生效，前提使用archaius的API来读取。 Spring Cloud Config俗称的配置中心，配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置，目前支持本地存储、Git以及Subversion。就是以后大家武器、枪火什么的东西都集中放到一起，别随便自己带，方便以后统一管理、升级装备。 Spring Cloud Bus事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与Spring Cloud Config联合实现热部署。相当于水浒传中日行八百里的神行太保戴宗，确保各个小弟之间消息保持畅通。 Spring Cloud for Cloud FoundryCloud Foundry是VMware推出的业界第一个开源PaaS云平台，它支持多种框架、语言、运行时环境、云平台及应用服务，使开发人员能够在几秒钟内进行应用程序的部署和扩展，无需担心任何基础架构的问题 其实就是与CloudFoundry进行集成的一套解决方案，抱了Cloud Foundry的大腿。 Spring Cloud ClusterSpring Cloud Cluster将取代Spring Integration。提供在分布式系统中的集群所需要的基础功能支持，如：选举、集群的状态一致性、全局锁、tokens等常见状态模式的抽象和实现。 如果把不同的帮派组织成统一的整体，Spring Cloud Cluster已经帮你提供了很多方便组织成统一的工具。 Spring Cloud ConsulConsul 是一个支持多数据中心分布式高可用的服务发现和配置共享的服务软件,由 HashiCorp 公司用 Go 语言开发, 基于 Mozilla Public License 2.0 的协议进行开源. Consul 支持健康检查,并允许 HTTP 和 DNS 协议调用 API 存储键值对. Spring Cloud Consul 封装了Consul操作，consul是一个服务发现与配置工具，与Docker容器可以无缝集成。 其它小弟Spring Cloud Security基于spring security的安全工具包，为你的应用程序添加安全控制。这个小弟很牛鼻专门负责整个帮派的安全问题，设置不同的门派访问特定的资源，不能把秘籍葵花宝典泄漏了。 Spring Cloud Sleuth日志收集工具包，封装了Dapper和log-based追踪以及Zipkin和HTrace操作，为SpringCloud应用实现了一种分布式追踪解决方案。 Spring Cloud Data FlowData flow 是一个用于开发和执行大范围数据处理其模式包括ETL，批量运算和持续运算的统一编程模型和托管服务。 对于在现代运行环境中可组合的微服务程序来说，Spring Cloud data flow是一个原生云可编配的服务。使用Spring Cloud data flow，开发者可以为像数据抽取，实时分析，和数据导入/导出这种常见用例创建和编配数据通道 （data pipelines）。 Spring Cloud data flow 是基于原生云对 spring XD的重新设计，该项目目标是简化大数据应用的开发。Spring XD 的流处理和批处理模块的重构分别是基于 Spring Boot的stream 和 task/batch 的微服务程序。这些程序现在都是自动部署单元而且他们原生的支持像 Cloud Foundry、Apache YARN、Apache Mesos和Kubernetes 等现代运行环境。 Spring Cloud data flow 为基于微服务的分布式流处理和批处理数据通道提供了一系列模型和最佳实践。 Spring Cloud StreamSpring Cloud Stream是创建消息驱动微服务应用的框架。Spring Cloud Stream是基于Spring Boot创建，用来建立单独的／工业级spring应用，使用spring integration提供与消息代理之间的连接。数据流操作开发包，封装了与Redis,Rabbit、Kafka等发送接收消息。 一个业务会牵扯到多个任务，任务之间是通过事件触发的，这就是Spring Cloud stream要干的事了 Spring Cloud TaskSpring Cloud Task 主要解决短命微服务的任务管理，任务调度的工作，比如说某些定时任务晚上就跑一次，或者某项数据分析临时就跑几次。 Spring Cloud ZookeeperZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。 操作Zookeeper的工具包，用于使用zookeeper方式的服务发现和配置管理，抱了Zookeeper的大腿。 Spring Cloud ConnectorsSpring Cloud Connectors 简化了连接到服务的过程和从云平台获取操作的过程，有很强的扩展性，可以利用Spring Cloud Connectors来构建你自己的云平台。 便于云端应用程序在各种PaaS平台连接到后端，如：数据库和消息代理服务。 Spring Cloud StartersSpring Boot式的启动项目，为Spring Cloud提供开箱即用的依赖管理。 Spring Cloud CLI基于 Spring Boot CLI，可以让你以命令行方式快速建立云组件。 和Spring Boot 是什么关系Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务，Spring Cloud是一个基于Spring Boot实现的云应用开发工具；Spring Boot专注于快速、方便集成的单个个体，Spring Cloud是关注全局的服务治理框架；Spring Boot使用了默认大于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置，Spring Cloud很大的一部分是基于Spring Boot来实现,可以不基于Spring Boot吗？不可以。 Spring Boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring Boot，属于依赖的关系。 spring -&gt; spring booot &gt; Spring Cloud 这样的关系。 Spring Cloud的优势微服务的框架那么多比如：dubbo、Kubernetes，为什么就要使用Spring Cloud的呢？ 产出于spring大家族，spring在企业级开发框架中无人能敌，来头很大，可以保证后续的更新、完善。 有Spring Boot 这个独立干将可以省很多事，大大小小的活Spring Boot都搞的挺不错。 作为一个微服务治理的大家伙，考虑的很全面，几乎服务治理的方方面面都考虑到了，方便开发开箱即用。 Spring Cloud 活跃度很高，教程很丰富，遇到问题很容易找到解决方案 轻轻松松几行代码就完成了熔断、均衡负载、服务中心的各种平台功能Spring Cloud对于中小型互联网公司来说是一种福音，因为这类公司往往没有实力或者没有足够的资金投入去开发自己的分布式系统基础设施，使用Spring Cloud一站式解决方案能在从容应对业务发展的同时大大减少开发成本。同时，随着近几年微服务架构和Docker容器概念的火爆，也会让Spring Cloud在未来越来越“云”化的软件开发风格中立有一席之地，尤其是在目前五花八门的分布式解决方案中提供了标准化的、全站式的技术方案，意义可能会堪比当前Servlet规范的诞生，有效推进服务端软件系统技术水平的进步。","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://java4all.cn/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://java4all.cn/tags/SpringCloud/"}]}]}